// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use itertools::Itertools;

use crate::{conversion::api::CxxBridgeIdent, types::QualifiedName};

/// Function to generate unique names for entries in the [cxx::bridge]
/// mod which is flat.
///
/// # All about the names involved in autocxx
///
/// A given function may have many, many names. From C++ to Rust...
///
/// 1. The actual C++ name. Fixed, obviously.
/// 2. The name reported by bindgen. Not always the same, as
///    bindgen may generate a different name for different overloads.
///    See `overload_tracker` for the conversion here.
/// 3. The name in the cxx::bridge mod. This is a flat namespace,
///    and it's the responsibility of this type to generate a
///    suitable name here.
///    If this is different from the C++ name in (1), we'll
///    add a #[cxx_name] attribute to the cxx::bridge declaration.
/// 4. The name in the code generated by cxx::bridge. This is currently
///    identical to 3 because we never use a #[rust_name] attribute.
/// 5. The name we wish to present to Rust users. Again, we have
///    to take stock of the fact Rust doesn't support overloading
///    so two different functions called 'get' may end up being
///    'get' and 'get1'. Yet, this may not be the same as the
///    bindgen name in (2) because we wish to generate such number
///    sequences on a per-type basis, whilst bindgen does it globally.
///
/// This fourth name, the final Rust user name, may be finagled
/// into place in different ways - see `RustRenameStrategy`.
///
/// This code generates the name for 3/4.
///
/// Returns the mangled name, and whether any mangling actually occurred.
pub(crate) fn mangle_for_cxx_bridge(
    type_name: Option<&str>,
    name: QualifiedName,
) -> (CxxBridgeIdent, bool) {
    // The output here doesn't _really_ matter, because it won't be visible
    // to users via APIs. But it will be visible in stack traces etc.
    // so let's try to make it obvious.
    // The goal is to mangle each name uniquely.

    let name_already_starts_with_mangling_prefix =
        name.segment_iter().next().unwrap().starts_with("_ACXX");

    // Simplest possible - no mangling at all.
    if name.get_namespace().is_empty() && !name.get_final_item().contains("_") {
        (
            CxxBridgeIdent::new(name.get_final_item().to_string()),
            false,
        )
    } else {
        let mangled = if !name.segment_iter().any(|seg| seg.contains('_'))
            && !name_already_starts_with_mangling_prefix
            && type_name.is_none()
        {
            // Simple: none of the segments have underscores. Just join the segments
            // using underscores.
            name.segment_iter().join("_")
        } else {
            // OK, we have to do some real mangling now.
            let mut buf = "_ACXX".to_string();
            for s in name.segment_iter() {
                buf.push_str(&format!("_{}", s.len()));
                buf.push_str(&s);
            }
            if let Some(type_name) = type_name {
                buf.push_str(&format!("_T{}", type_name.len()));
                buf.push_str(type_name);
            }
            buf
        };
        (CxxBridgeIdent::new(mangled), true)
    }
}

#[cfg(test)]
mod tests {
    use quote::ToTokens;

    use crate::types::{make_ident, Namespace, QualifiedName};

    fn mangle_for_cxx_bridge(type_name: Option<&str>, name: &str, ns: &Namespace) -> String {
        let qn = QualifiedName::new(ns, make_ident(name));
        let (new_name, _) = super::mangle_for_cxx_bridge(type_name, qn);
        new_name.to_token_stream().to_string()
    }

    #[test]
    fn test() {
        let ns_root = Namespace::new();
        let ns_a = Namespace::from_user_input("A");
        let ns_ab = Namespace::from_user_input("A::B");
        let ns_abb = Namespace::from_user_input("A::B_B");
        let ns_acxx = Namespace::from_user_input("_ACXX");
        assert_eq!(mangle_for_cxx_bridge(None, "do", &ns_root), "do");
        assert_eq!(mangle_for_cxx_bridge(None, "do", &ns_a), "A_do");
        assert_eq!(mangle_for_cxx_bridge(None, "do", &ns_ab), "A_B_do");
        assert_eq!(
            mangle_for_cxx_bridge(None, "do", &ns_abb),
            "_ACXX_1A_3B_B_2do"
        );
        assert_eq!(
            mangle_for_cxx_bridge(None, "doe_a_deer", &ns_root),
            "_ACXX_10doe_a_deer"
        );
        assert_eq!(
            mangle_for_cxx_bridge(None, "_ACXX", &ns_root),
            "_ACXX_5_ACXX"
        );
        assert_eq!(
            mangle_for_cxx_bridge(None, "_ACXX", &ns_a),
            "_ACXX_1A_5_ACXX"
        );
        assert_eq!(
            mangle_for_cxx_bridge(None, "do", &ns_acxx),
            "_ACXX_5_ACXX_2do"
        );
        assert_eq!(
            mangle_for_cxx_bridge(Some("ty1"), "do", &ns_root),
            "_ACXX_2do_T3ty1"
        );
        assert_eq!(
            mangle_for_cxx_bridge(Some("ty"), "do", &ns_a),
            "_ACXX_1A_2do_T2ty"
        );
        assert_eq!(
            mangle_for_cxx_bridge(Some("ty"), "do", &ns_ab),
            "_ACXX_1A_1B_2do_T2ty"
        );
    }
}
