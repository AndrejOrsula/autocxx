// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::cpp_postprocessor::{EncounteredType, EncounteredTypeKind};
use lazy_static::lazy_static;
use proc_macro2::Span;
use quote::quote;
use std::collections::{HashMap, HashSet};
use syn::punctuated::Punctuated;
use syn::Token;
use syn::{
    parse_quote, AngleBracketedGenericArguments, Attribute, FnArg, ForeignItem, ForeignItemFn,
    GenericArgument, Ident, Item, ItemEnum, ItemForeignMod, ItemMod, ItemStruct, PatType, Path,
    PathArguments, PathSegment, ReturnType, Type, TypePath, TypePtr, TypeReference,
};

lazy_static! {
    /// Substitutions from the names constructed by bindgen into those
    /// which cxx uses.
    static ref IDENT_REPLACEMENTS: HashMap<&'static str, String> = {
        let mut map = HashMap::new();
        map.insert("std_unique_ptr", "UniquePtr".to_string());
        map.insert("std_string", "CxxString".to_string());
        map
    };
}

#[derive(Debug)]
pub enum ConvertError {
    NoContent,
}

pub(crate) struct BridgeConversionResults {
    pub output: ItemMod,
    pub types_encountered: Vec<EncounteredType>,
}

/// Converts the bindings generated by bindgen into a form suitable
/// for use with `cxx`.
/// Tasks current performed:
/// * Replaces certain identifiers e.g. `std_unique_ptr` with `UniquePtr`
/// * Replaces pointers with references
/// * Removes repr attributes
/// * Removes link_name attributes
/// * Adds include! directives
/// * Adds #[cxx::bridge]
/// At the moment this is almost certainly not using the best practice for parsing
/// stuff. It's multiple simple-but-yucky state machines. Can undoubtedly be
/// simplified and made less error-prone: TODO. Probably the right thing to do
/// is just manipulate the syn types directly.
pub(crate) struct BridgeConverter {
    include_list: Vec<String>,
    old_rust: bool,
    class_names_discovered: HashSet<String>,
}

impl BridgeConverter {
    pub fn new(include_list: Vec<String>, old_rust: bool) -> Self {
        Self {
            include_list,
            old_rust,
            class_names_discovered: HashSet::new(),
        }
    }

    fn append_cpp_definition_squasher(&self, ident: Ident, item: Item) -> Vec<Item> {
        let mut out = vec![];
        if !self.old_rust {
            out.push(Item::Verbatim(quote! {
                unsafe extern "C++" {
                    type #ident;
                }
            }));
        }
        out.push(item);
        out
    }

    /// Convert a TokenStream of bindgen-generated bindings to a form
    /// suitable for cxx.
    pub(crate) fn convert(
        &mut self,
        bindings: ItemMod,
    ) -> Result<BridgeConversionResults, ConvertError> {
        let mut types_encountered = Vec::new();
        match bindings.content {
            None => Err(ConvertError::NoContent),
            Some((brace, items)) => {
                let mut new_items = Vec::new();
                for item in items {
                    new_items.append(&mut match item {
                        Item::ForeignMod(fm) => {
                            vec![self.convert_foreign_mod(fm).map(Item::ForeignMod)?]
                        }
                        Item::Struct(s) => {
                            let tyname = s.ident.clone();
                            types_encountered.push(EncounteredType(
                                EncounteredTypeKind::Struct,
                                tyname.to_string().to_owned(),
                            ));
                            let new_struct_def = Item::Struct(self.convert_struct(s));
                            self.append_cpp_definition_squasher(tyname, new_struct_def)
                        }
                        Item::Enum(e) => {
                            let tyname = e.ident.clone();
                            types_encountered.push(EncounteredType(
                                EncounteredTypeKind::Enum,
                                tyname.to_string().to_owned(),
                            ));
                            let new_enum_def = self.convert_enum(e).map(Item::Enum)?;
                            self.append_cpp_definition_squasher(tyname, new_enum_def)
                        }
                        Item::Impl(_) => vec![],
                        _ => vec![item], // TODO - consider rejecting
                    });
                }
                Ok(BridgeConversionResults {
                    output: ItemMod {
                        attrs: bindings.attrs,
                        ident: bindings.ident,
                        semi: bindings.semi,
                        mod_token: bindings.mod_token,
                        vis: bindings.vis,
                        content: Some((brace, new_items)),
                    },
                    types_encountered,
                })
            }
        }
    }

    fn convert_foreign_mod(
        &self,
        foreign_mod: ItemForeignMod,
    ) -> Result<ItemForeignMod, ConvertError> {
        let mut new_items = Vec::new();
        for inc in &self.include_list {
            let new_bit = parse_quote! {
                include!(#inc);
            };
            new_items.push(ForeignItem::Macro(new_bit));
        }
        for i in foreign_mod.items {
            new_items.push(match i {
                ForeignItem::Fn(f) => self.convert_foreign_fn(f).map(ForeignItem::Fn)?,
                _ => i,
            })
        }
        Ok(ItemForeignMod {
            attrs: foreign_mod.attrs,
            abi: foreign_mod.abi,
            brace_token: foreign_mod.brace_token,
            items: new_items,
        })
    }

    fn convert_foreign_fn(&self, fun: ForeignItemFn) -> Result<ForeignItemFn, ConvertError> {
        let mut s = fun.sig.clone();
        s.output = self.convert_return_type(s.output);
        let (new_params, any_this): (Punctuated<_, _>, Vec<_>) = fun
            .sig
            .inputs
            .into_iter()
            .map(|i| self.convert_fn_arg(i))
            .unzip();
        s.inputs = new_params;
        let is_a_method = any_this.iter().any(|b| *b);
        if is_a_method {
            // bindgen generates methods with the name:
            // {class}_{method name}
            // It then generates an impl section for the Rust type
            // with the original name, but we currently discard that impl section.
            // We want to feed cxx methods with just the method name, so let's
            // strip off the class name.
            // TODO test with class names containing underscores. It should work.
            let old_name = s.ident.to_string();
            for cn in &self.class_names_discovered {
                if old_name.starts_with(cn) {
                    s.ident = Ident::new(&old_name[cn.len() + 1..], s.ident.span());
                    break;
                }
            }
        }
        Ok(ForeignItemFn {
            attrs: self.strip_attr(fun.attrs, "link_name"),
            vis: fun.vis,
            sig: s,
            semi_token: fun.semi_token,
        })
    }

    fn convert_struct(&mut self, ty: ItemStruct) -> ItemStruct {
        self.class_names_discovered.insert(ty.ident.to_string());
        ItemStruct {
            attrs: self.strip_attr(ty.attrs, "repr"),
            vis: ty.vis,
            struct_token: ty.struct_token,
            generics: ty.generics,
            fields: ty.fields,
            semi_token: ty.semi_token,
            ident: ty.ident,
        }
    }

    fn convert_enum(&self, ty: ItemEnum) -> Result<ItemEnum, ConvertError> {
        Ok(ItemEnum {
            // TODO tidy next line
            attrs: self.strip_attr(self.strip_attr(ty.attrs, "repr"), "derive"),
            vis: ty.vis,
            enum_token: ty.enum_token,
            generics: ty.generics,
            variants: ty.variants,
            brace_token: ty.brace_token,
            ident: ty.ident,
        })
    }

    fn strip_attr(&self, attrs: Vec<Attribute>, to_strip: &str) -> Vec<Attribute> {
        attrs
            .into_iter()
            .filter(|a| {
                let i = a.path.get_ident();
                !matches!(i, Some(i2) if *i2 == to_strip)
            })
            .collect::<Vec<Attribute>>()
    }

    /// Returns additionally a Boolean indicating whether an argument was
    /// 'this'
    fn convert_fn_arg(&self, arg: FnArg) -> (FnArg, bool) {
        match arg {
            FnArg::Typed(pt) => {
                let mut found_this = false;
                let old_pat = *pt.pat;
                let new_pat = match old_pat {
                    syn::Pat::Ident(pp) if pp.ident.to_string() == "this" => {
                        found_this = true;
                        syn::Pat::Ident(syn::PatIdent {
                            attrs: pp.attrs,
                            by_ref: pp.by_ref,
                            mutability: pp.mutability,
                            subpat: pp.subpat,
                            ident: Ident::new("self", pp.ident.span()),
                        })
                    }
                    _ => old_pat,
                };
                (
                    FnArg::Typed(PatType {
                        attrs: pt.attrs,
                        pat: Box::new(new_pat),
                        colon_token: pt.colon_token,
                        ty: self.convert_boxed_type(pt.ty),
                    }),
                    found_this,
                )
            }
            _ => (arg, false),
        }
    }

    fn convert_return_type(&self, rt: ReturnType) -> ReturnType {
        match rt {
            ReturnType::Default => ReturnType::Default,
            ReturnType::Type(rarrow, typebox) => {
                ReturnType::Type(rarrow, self.convert_boxed_type(typebox))
            }
        }
    }

    fn convert_boxed_type(&self, ty: Box<Type>) -> Box<Type> {
        Box::new(self.convert_type(*ty))
    }

    fn convert_type(&self, ty: Type) -> Type {
        match ty {
            Type::Path(p) => Type::Path(self.convert_type_path(p)),
            Type::Reference(r) => Type::Reference(TypeReference {
                and_token: r.and_token,
                lifetime: r.lifetime,
                mutability: r.mutability,
                elem: self.convert_boxed_type(r.elem),
            }),
            Type::Ptr(ptr) => Type::Reference(self.convert_ptr_to_reference(ptr)),
            _ => ty,
        }
    }

    fn convert_ptr_to_reference(&self, ptr: TypePtr) -> TypeReference {
        TypeReference {
            and_token: Token![&](Span::call_site()),
            lifetime: None,
            mutability: ptr.mutability,
            elem: self.convert_boxed_type(ptr.elem),
        }
    }

    fn convert_type_path(&self, typ: TypePath) -> TypePath {
        let p = typ.path;
        let new_p = Path {
            leading_colon: p.leading_colon,
            segments: p
                .segments
                .into_iter()
                .map(|s| {
                    let old_ident = s.ident.to_string();
                    let args = match s.arguments {
                        PathArguments::AngleBracketed(ab) => {
                            PathArguments::AngleBracketed(AngleBracketedGenericArguments {
                                colon2_token: ab.colon2_token,
                                lt_token: ab.lt_token,
                                gt_token: ab.gt_token,
                                args: self.convert_punctuated(ab.args),
                            })
                        }
                        _ => s.arguments,
                    };
                    let ident = match IDENT_REPLACEMENTS.get(old_ident.as_str()) {
                        None => s.ident,
                        Some(replacement) => Ident::new(replacement, s.ident.span()),
                    };
                    PathSegment {
                        ident,
                        arguments: args,
                    }
                })
                .collect(),
        };
        TypePath {
            qself: typ.qself,
            path: new_p,
        }
    }

    fn convert_punctuated<P>(
        &self,
        pun: Punctuated<GenericArgument, P>,
    ) -> Punctuated<GenericArgument, P>
    where
        P: Default,
    {
        let mut new_pun = Punctuated::new();
        for arg in pun.into_iter() {
            new_pun.push(match arg {
                GenericArgument::Type(t) => GenericArgument::Type(self.convert_type(t)),
                _ => arg,
            });
        }
        new_pun
    }
}
