// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use lazy_static::lazy_static;
use log::info;
use proc_macro2::Group;
use proc_macro2::TokenStream as TokenStream2;
use proc_macro2::TokenTree as TokenTree2;
use quote::{quote, TokenStreamExt};
use std::collections::HashMap;

lazy_static! {
    /// Substitutions from the names constructed by bindgen into those
    /// which cxx uses.
    static ref IDENT_REPLACEMENTS: HashMap<&'static str, String> = {
        let mut map = HashMap::new();
        map.insert("std_unique_ptr", "UniquePtr".to_string());
        map.insert("std_string", "CxxString".to_string());
        map
    };
}

#[derive(Debug)]
pub enum ConvertError {
    NoModFound,
    NoFfiFound,
    NoActualGroupFound,
    NoCFound,
    NoExternCGroupFound,
    ExtraFoundInExtern,
    NoGroupAfterAttribute,
}

enum OuterState {
    Start,
    FoundMod,
    FoundFfi,
}

enum ModFfiState {
    Start,
    FoundAttribute,
    FoundExtern,
    FoundC,
}

enum ExternCState {
    Start,
    FoundAttribute,
}

const OUTPUT_TOKENS: bool = false;

/// Converts the bindings generated by bindgen into a form suitable
/// for use with `cxx`.
/// Tasks current performed:
/// * Replaces certain identifiers e.g. `std_unique_ptr` with `UniquePtr`
/// * Replaces pointers with references
/// * Removes repr attributes
/// * Removes link_name attributes
/// * Adds include! directives
/// * Adds #[cxx::bridge]
/// At the moment this is almost certainly not using the best practice for parsing
/// stuff. It's multiple simple-but-yucky state machines. Can undoubtedly be
/// simplified and made less error-prone: TODO. Probably the right thing to do
/// is just manipulate the syn types directly.
pub(crate) struct BridgeConverter {
    include_list: Vec<String>,
}

impl BridgeConverter {
    pub fn new(include_list: Vec<String>) -> Self {
        Self { include_list }
    }

    /// Convert a TokenStream of bindgen-generated bindings to a form
    /// suitable for cxx.
    pub(crate) fn convert(&self, bindings: TokenStream2) -> Result<TokenStream2, ConvertError> {
        let mut state = OuterState::Start;
        let mut new_ts = quote! {
            #[cxx::bridge]
            mod ffi
        };
        for t in bindings {
            state = match state {
                OuterState::Start => match t {
                    TokenTree2::Ident(i) if i.to_string() == "mod" => OuterState::FoundMod,
                    _ => return Err(ConvertError::NoModFound),
                },
                OuterState::FoundMod => match t {
                    TokenTree2::Ident(i) if i.to_string() == "ffi" => OuterState::FoundFfi,
                    _ => return Err(ConvertError::NoFfiFound),
                },
                OuterState::FoundFfi => match t {
                    TokenTree2::Group(g) => {
                        new_ts.append(self.convert_mod_ffi(g)?);
                        OuterState::Start
                    }
                    _ => return Err(ConvertError::NoActualGroupFound),
                },
            }
        }
        Ok(new_ts)
    }

    fn convert_mod_ffi(&self, mod_ffi_group: Group) -> Result<Group, ConvertError> {
        let mut state = ModFfiState::Start;
        let mut new_ts = TokenStream2::new();
        for t in mod_ffi_group.stream() {
            state = match state {
                ModFfiState::Start => match t {
                    TokenTree2::Ident(ref i) if i.to_string() == "extern" => {
                        new_ts.append(t);
                        ModFfiState::FoundExtern
                    }
                    TokenTree2::Punct(p) if p.to_string() == "#" => ModFfiState::FoundAttribute,
                    _ => {
                        new_ts.append(t);
                        ModFfiState::Start
                    }
                },
                ModFfiState::FoundExtern => match t {
                    TokenTree2::Literal(ref l) if l.to_string() == "\"C\"" => {
                        new_ts.append(t);
                        ModFfiState::FoundC
                    }
                    _ => return Err(ConvertError::NoCFound),
                },
                ModFfiState::FoundC => match t {
                    TokenTree2::Group(g) => {
                        new_ts.append(self.convert_extern_c(g)?);
                        ModFfiState::Start
                    }
                    _ => return Err(ConvertError::NoActualGroupFound),
                },
                ModFfiState::FoundAttribute => match t {
                    TokenTree2::Group(_) => ModFfiState::Start,
                    _ => return Err(ConvertError::NoGroupAfterAttribute),
                },
            };
        }
        Ok(Group::new(mod_ffi_group.delimiter(), new_ts))
    }

    fn convert_extern_c(&self, extern_c_group: Group) -> Result<Group, ConvertError> {
        let mut state = ExternCState::Start;
        let mut filtered_ts = TokenStream2::new();
        for t in extern_c_group.stream() {
            state = match state {
                ExternCState::Start => match t {
                    TokenTree2::Punct(p) if p.to_string() == "#" => ExternCState::FoundAttribute,
                    _ => {
                        filtered_ts.append(t);
                        ExternCState::Start
                    }
                },
                ExternCState::FoundAttribute => match t {
                    TokenTree2::Group(_) => ExternCState::Start,
                    _ => return Err(ConvertError::NoGroupAfterAttribute),
                },
            }
        }
        let mut new_ts = TokenStream2::new();
        for incl in &self.include_list {
            new_ts.append_all(quote! {
                include!(#incl);
            });
        }
        new_ts.append_all(self.substitute_idents_and_pointers(filtered_ts, 0));
        Ok(Group::new(extern_c_group.delimiter(), new_ts))
    }

    fn substitute_idents_and_pointers(
        &self,
        bindings: TokenStream2,
        indent: usize,
    ) -> TokenStream2 {
        let prefix = std::iter::repeat(" ").take(indent).collect::<String>();
        let mut new_ts = TokenStream2::new();
        for t in bindings {
            if OUTPUT_TOKENS {
                info!("{}TOKEN: {}", prefix, t);
            }
            let replacement = match t {
                TokenTree2::Ident(i) if i.to_string() == "const" => None,
                TokenTree2::Ident(i) => {
                    let name = i.to_string();
                    let e = IDENT_REPLACEMENTS.get(name.as_str());
                    Some(match e {
                        Some(s) => TokenTree2::Ident(proc_macro2::Ident::new(s, i.span())),
                        None => TokenTree2::Ident(i),
                    })
                }
                TokenTree2::Punct(p) if p.as_char() == '*' => {
                    Some(TokenTree2::Punct(proc_macro2::Punct::new('&', p.spacing())))
                }
                TokenTree2::Punct(p) => Some(TokenTree2::Punct(p)),
                TokenTree2::Literal(l) => Some(TokenTree2::Literal(l)),
                TokenTree2::Group(g) => {
                    let delim = g.delimiter();
                    let replacement_tokens =
                        self.substitute_idents_and_pointers(g.stream(), indent + 1);
                    Some(TokenTree2::Group(proc_macro2::Group::new(
                        delim,
                        replacement_tokens,
                    )))
                }
            };
            if let Some(repl) = replacement {
                new_ts.append(repl);
            }
        }
        new_ts
    }
}
