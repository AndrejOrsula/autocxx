// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::byvalue_checker::ByValueChecker;
use crate::types::TypeName;
use crate::{
    additional_cpp_generator::{AdditionalNeed, ArgumentConversion, ByValueWrapper},
    types::{replace_type_path_without_arguments, should_dereference_in_cpp},
};
use proc_macro2::{Span, TokenStream as TokenStream2, TokenTree};
use syn::{
    parse_quote, Attribute, FnArg, ForeignItem, ForeignItemFn, GenericArgument, Ident, Item,
    ItemForeignMod, ItemMod, PathArguments, PathSegment, ReturnType, Type, TypePath, TypePtr,
    TypeReference,
};
use syn::{punctuated::Punctuated, Pat};

#[derive(Debug)]
pub enum ConvertError {
    NoContent,
    UnsafePODType(String),
    UnknownForeignItem,
    DuplicateType(String),
}

/// Results of a conversion.
pub(crate) struct BridgeConversionResults {
    pub items: Vec<Item>,
    pub additional_cpp_needs: Vec<AdditionalNeed>,
}

/// Converts the bindings generated by bindgen into a form suitable
/// for use with `cxx`.
/// Tasks current performed:
/// * Replaces certain identifiers e.g. `std_unique_ptr` with `UniquePtr`
/// * Replaces pointers with references
/// * Removes repr attributes
/// * Removes link_name attributes
/// * Adds include! directives
/// * Adds #[cxx::bridge]
/// At the moment this is almost certainly not using the best practice for parsing
/// stuff. It's multiple simple-but-yucky state machines. Can undoubtedly be
/// simplified and made less error-prone: TODO. Probably the right thing to do
/// is just manipulate the syn types directly.
pub(crate) struct BridgeConverter {
    include_list: Vec<String>,
    pod_requests: Vec<TypeName>,
}

impl BridgeConverter {
    pub fn new(include_list: Vec<String>, pod_requests: Vec<TypeName>) -> Self {
        Self {
            include_list,
            pod_requests,
        }
    }

    /// Convert a TokenStream of bindgen-generated bindings to a form
    /// suitable for cxx.
    pub(crate) fn convert(
        &mut self,
        bindings: ItemMod,
        exclude_utilities: bool,
    ) -> Result<BridgeConversionResults, ConvertError> {
        match bindings.content {
            None => Err(ConvertError::NoContent),
            Some((brace, items)) => {
                let bindgen_mod = ItemMod {
                    attrs: bindings.attrs,
                    vis: bindings.vis,
                    ident: bindings.ident,
                    mod_token: bindings.mod_token,
                    content: Some((brace, Vec::new())),
                    semi: bindings.semi,
                };
                let conversion = BridgeConversion {
                    bindgen_mod,
                    all_items: Vec::new(),
                    bridge_items: Vec::new(),
                    extern_c_mod: None,
                    extern_c_mod_items: Vec::new(),
                    additional_cpp_needs: Vec::new(),
                    types_found: Vec::new(),
                    bindgen_root_items: Vec::new(),
                    byvalue_checker: ByValueChecker::new(),
                    pod_requests: &self.pod_requests,
                    include_list: &self.include_list,
                };
                conversion.convert_items(items, exclude_utilities)
            }
        }
    }
}

struct BridgeConversion<'a> {
    bindgen_mod: ItemMod,
    all_items: Vec<Item>,
    bridge_items: Vec<Item>,
    extern_c_mod: Option<ItemForeignMod>,
    extern_c_mod_items: Vec<ForeignItem>,
    additional_cpp_needs: Vec<AdditionalNeed>,
    types_found: Vec<Ident>,
    bindgen_root_items: Vec<Item>,
    byvalue_checker: ByValueChecker,
    pod_requests: &'a Vec<TypeName>,
    include_list: &'a Vec<String>,
}

fn make_ident(id: &str) -> Ident {
    Ident::new(id, Span::call_site())
}

impl<'a> BridgeConversion<'a> {
    fn find_nested_pod_types(
        &mut self,
        items: &[Item],
        ns: Vec<String>,
    ) -> Result<(), ConvertError> {
        for item in items {
            match item {
                Item::Struct(s) => self.byvalue_checker.ingest_struct(s, &ns),
                Item::Enum(e) => self
                    .byvalue_checker
                    .ingest_pod_type(TypeName::new(&ns, &e.ident.to_string())),
                Item::Mod(itm) => {
                    if let Some((_, nested_items)) = &itm.content {
                        let mut new_ns = ns.clone();
                        new_ns.push(itm.ident.to_string());
                        self.find_nested_pod_types(nested_items, new_ns)?;
                    }
                }
                _ => {}
            }
        }
        self.byvalue_checker
            .satisfy_requests(self.pod_requests.clone())
            .map_err(ConvertError::UnsafePODType)
    }

    fn generate_type_alias(
        &mut self,
        tyname: TypeName,
        should_be_pod: bool,
    ) -> Result<(), ConvertError> {
        let final_ident = make_ident(tyname.get_final_ident());
        if self.types_found.contains(&final_ident) {
            // At the moment we can only have a single type with a given name,
            // even in different namespaces. This is a temporary problem.
            return Err(ConvertError::DuplicateType(final_ident.to_string()));
        }
        let kind_item = make_ident(if should_be_pod { "Trivial" } else { "Opaque" });
        let tynamestring = tyname.to_cpp_name();
        let mut for_extern_c_ts = TokenStream2::new();
        let mut fulltypath = Vec::new();
        for_extern_c_ts.extend(
            [
                TokenTree::Ident(make_ident("type")),
                TokenTree::Ident(final_ident.clone()),
                TokenTree::Punct(proc_macro2::Punct::new('=', proc_macro2::Spacing::Alone)),
                TokenTree::Ident(make_ident("super")),
                TokenTree::Punct(proc_macro2::Punct::new(':', proc_macro2::Spacing::Joint)),
                TokenTree::Punct(proc_macro2::Punct::new(':', proc_macro2::Spacing::Joint)),
                TokenTree::Ident(make_ident("bindgen")),
                TokenTree::Punct(proc_macro2::Punct::new(':', proc_macro2::Spacing::Joint)),
                TokenTree::Punct(proc_macro2::Punct::new(':', proc_macro2::Spacing::Joint)),
                TokenTree::Ident(make_ident("root")),
                TokenTree::Punct(proc_macro2::Punct::new(':', proc_macro2::Spacing::Joint)),
                TokenTree::Punct(proc_macro2::Punct::new(':', proc_macro2::Spacing::Joint)),
            ]
            .to_vec(),
        );
        fulltypath.push(make_ident("bindgen"));
        fulltypath.push(make_ident("root"));
        for segment in tyname.ns_segment_iter() {
            let id = make_ident(segment);
            for_extern_c_ts.extend(
                [
                    TokenTree::Ident(id.clone()),
                    TokenTree::Punct(proc_macro2::Punct::new(':', proc_macro2::Spacing::Joint)),
                    TokenTree::Punct(proc_macro2::Punct::new(':', proc_macro2::Spacing::Joint)),
                ]
                .to_vec(),
            );
            fulltypath.push(id);
        }
        for_extern_c_ts.extend(
            [
                TokenTree::Ident(final_ident.clone()),
                TokenTree::Punct(proc_macro2::Punct::new(';', proc_macro2::Spacing::Alone)),
            ]
            .to_vec(),
        );
        fulltypath.push(final_ident.clone());
        self.extern_c_mod_items
            .push(ForeignItem::Verbatim(for_extern_c_ts));
        self.bridge_items.push(Item::Impl(parse_quote! {
            impl UniquePtr<#final_ident> {}
        }));
        self.all_items.push(Item::Impl(parse_quote! {
            unsafe impl cxx::ExternType for #(#fulltypath)::* {
                type Id = cxx::type_id!(#tynamestring);
                type Kind = cxx::kind::#kind_item;
            }
        }));
        self.types_found.push(final_ident);
        Ok(())
    }

    fn build_include_foreign_items(&self) -> Vec<ForeignItem> {
        let extra_inclusion = if self.additional_cpp_needs.is_empty() {
            None
        } else {
            Some("autocxxgen.h".to_string())
        };
        println!("cargo:warning=Extra include: {:?}", extra_inclusion);
        let chained = self.include_list.iter().chain(extra_inclusion.iter());
        chained
            .map(|inc| {
                ForeignItem::Macro(parse_quote! {
                    include!(#inc);
                })
            })
            .collect()
    }

    fn convert_items(
        mut self,
        items: Vec<Item>,
        exclude_utilities: bool,
    ) -> Result<BridgeConversionResults, ConvertError> {
        if !exclude_utilities {
            self.generate_utilities();
        }
        let mut bindgen_root_mod = parse_quote! {
            mod root {}
        };
        for item in items {
            match item {
                Item::Mod(root_mod) => {
                    assert!(root_mod.ident.to_string() == "root");
                    bindgen_root_mod = root_mod.clone();
                    if let Some((_, items)) = root_mod.content {
                        self.find_nested_pod_types(&items, Vec::new())?;
                        self.convert_mod_items(items, Vec::new())?;
                    }
                }
                _ => panic!("Unexpected outer item"),
            }
        }
        self.extern_c_mod_items.extend(self.build_include_foreign_items());
        // We will always create an extern "C" mod even if bindgen
        // didn't generate one, e.g. because it only generated types.
        // We still want cxx to know about those types.
        let mut extern_c_mod = self
            .extern_c_mod
            .take()
            .unwrap_or_else(|| self.get_blank_extern_c_mod());
        extern_c_mod.items.append(&mut self.extern_c_mod_items);
        self.bridge_items.push(Item::ForeignMod(extern_c_mod));
        self.bindgen_root_items.push(Item::Use(parse_quote! {
            #[allow(unused_imports)]
            use self::super::super::cxxbridge;
        }));
        bindgen_root_mod.content.as_mut().unwrap().1 = self.bindgen_root_items;
        self.bindgen_mod.content.as_mut().unwrap().1 = vec![Item::Mod(bindgen_root_mod)];
        self.all_items.push(Item::Mod(self.bindgen_mod.clone()));
        let mut bridge_mod: ItemMod = parse_quote! {
            #[cxx::bridge]
            pub mod cxxbridge {
            }
        };
        bridge_mod
            .content
            .as_mut()
            .unwrap()
            .1
            .append(&mut self.bridge_items);
        self.all_items.push(Item::Mod(bridge_mod));
        Ok(BridgeConversionResults {
            items: self.all_items,
            additional_cpp_needs: self.additional_cpp_needs,
        })
    }

    fn convert_mod_items(&mut self, items: Vec<Item>, ns: Vec<String>) -> Result<(), ConvertError> {
        for item in items {
            match item {
                Item::ForeignMod(mut fm) => {
                    let items = fm.items;
                    fm.items = Vec::new();
                    if self.extern_c_mod.is_none() {
                        self.extern_c_mod = Some(fm);
                        // We'll use the first 'extern "C"' mod we come
                        // across for attributes, spans etc. but we'll stuff
                        // the contents of all bindgen 'extern "C"' mods into this
                        // one.
                    }
                    self.convert_foreign_mod_items(items)?;
                }
                Item::Struct(mut s) => {
                    let tyname = TypeName::new(&ns, &s.ident.to_string());
                    let should_be_pod = self.byvalue_checker.is_pod(&tyname);
                    self.generate_type_alias(tyname, should_be_pod)?;
                    if !should_be_pod {
                        // See cxx's opaque::Opaque for rationale for this type... in
                        // short, it's to avoid being Send/Sync.
                        s.fields = syn::Fields::Named(parse_quote! {
                            {
                                do_not_attempt_to_allocate_nonpod_types: [*const u8; 0],
                            }
                        });
                        // Thanks to dtolnay@ for this explanation of why the following
                        // is needed:
                        // If the real alignment of the C++ type is smaller and a reference
                        // is returned from C++ to Rust, mere existence of an insufficiently
                        // aligned reference in Rust causes UB even if never dereferenced
                        // by Rust code
                        // (see https://doc.rust-lang.org/1.47.0/reference/behavior-considered-undefined.html).
                        // Rustc can use least-significant bits of the reference for other storage.
                        s.attrs.push(parse_quote!(
                            #[repr(C, packed)]
                        ));
                    }
                    self.bindgen_root_items.push(Item::Struct(s));
                }
                Item::Enum(e) => {
                    let tyname = TypeName::new(&ns, &e.ident.to_string());
                    self.generate_type_alias(tyname, true)?;
                    self.bindgen_root_items.push(Item::Enum(e));
                }
                Item::Impl(i) => {
                    if let Some(ty) = self.type_to_typename(&i.self_ty) {
                        for item in i.items.clone() {
                            match item {
                                syn::ImplItem::Method(m) if m.sig.ident == "new" => {
                                    self.convert_new_method(m, &ty, &i)
                                }
                                _ => {}
                            }
                        }
                    }
                }
                Item::Mod(itm) => {
                    if let Some((_, items)) = itm.content {
                        let mut new_ns = ns.clone();
                        new_ns.push(itm.ident.to_string());
                        self.convert_mod_items(items, new_ns)?;
                    }
                }
                Item::Use(_) => {
                    // Should only appear in the bindgen root. As far as I know...
                    self.bindgen_root_items.push(item);
                }
                Item::Const(_) => {
                    self.all_items.push(item);
                }
                _ => {
                    //panic!(format!("Unhandled item: {:?}", item));
                }
            }
        }
        Ok(())
    }

    /// Adds items which we always add, cos they're useful.
    fn generate_utilities(&mut self) {
        // Unless we've been specifically asked not to do so, we always
        // generate a 'make_string' function. That pretty much *always* means
        // we run two passes through bindgen. i.e. the next 'if' is always true,
        // and we always generate an additional C++ file for our bindings additions,
        // unless the include_cpp macro has specified ExcludeUtilities.
        self.extern_c_mod_items.push(ForeignItem::Fn(parse_quote!(
            fn make_string(str_: &str) -> UniquePtr<CxxString>;
        )));
        self.additional_cpp_needs.push(AdditionalNeed::MakeStringConstructor);
    }

    fn convert_new_method(&mut self, mut m: syn::ImplItemMethod, ty: &TypeName, i: &syn::ItemImpl) {
        let self_ty = i.self_ty.as_ref();
        let (arrow, oldreturntype) = match &m.sig.output {
            ReturnType::Type(arrow, ty) => (arrow, ty),
            ReturnType::Default => return,
        };
        let cpp_constructor_args = m.sig.inputs.iter().filter_map(|x| match x {
            FnArg::Typed(pt) => {
                self.type_to_typename(&pt.ty)
                    .and_then(|x| match *(pt.pat.clone()) {
                        syn::Pat::Ident(pti) => Some((x, pti.ident)),
                        _ => None,
                    })
            }
            FnArg::Receiver(_) => None,
        });
        let (cpp_arg_types, cpp_arg_names): (Vec<_>, Vec<_>) = cpp_constructor_args.unzip();
        let rs_args = &m.sig.inputs;
        self.additional_cpp_needs
            .push(AdditionalNeed::MakeUnique(ty.clone(), cpp_arg_types));
        // Create a function which calls Bob_make_unique
        // from Bob::make_unique.
        let call_name = Ident::new(
            &format!("{}_make_unique", ty.to_string()),
            Span::call_site(),
        );
        self.extern_c_mod_items.push(ForeignItem::Fn(parse_quote! {
            pub fn #call_name ( #rs_args ) -> UniquePtr< #self_ty >;
        }));
        m.block = parse_quote!( {
            cxxbridge::#call_name(
                #(#cpp_arg_names),*
            )
        });
        m.sig.ident = Ident::new("make_unique", Span::call_site());
        let new_return_type: TypePath = parse_quote! {
            cxx::UniquePtr < #oldreturntype >
        };
        m.sig.unsafety = None;
        m.sig.output = ReturnType::Type(*arrow, Box::new(Type::Path(new_return_type)));
        let new_impl_method = syn::ImplItem::Method(m);
        let mut new_item_impl = i.clone();
        new_item_impl.attrs = Vec::new();
        new_item_impl.unsafety = None;
        new_item_impl.items = vec![new_impl_method];
        self.bindgen_root_items.push(Item::Impl(new_item_impl));
    }

    fn get_blank_extern_c_mod(&self) -> ItemForeignMod {
        parse_quote!(
            extern "C" {}
        )
    }

    fn type_to_typename(&self, ty: &Type) -> Option<TypeName> {
        match ty {
            Type::Path(pn) => Some(TypeName::from_bindgen_type_path(pn)),
            _ => None,
        }
    }

    fn convert_foreign_mod_items(
        &mut self,
        foreign_mod_items: Vec<ForeignItem>,
    ) -> Result<(), ConvertError> {
        for i in foreign_mod_items {
            match i {
                ForeignItem::Fn(f) => {
                    self.convert_foreign_fn(f)?;
                }
                _ => return Err(ConvertError::UnknownForeignItem),
            }
        }
        Ok(())
    }

    fn convert_foreign_fn(&mut self, fun: ForeignItemFn) -> Result<(), ConvertError> {
        let mut s = fun.sig.clone();
        let old_name = s.ident.to_string();
        // See if it's a constructor, in which case skip it.
        // We instead pass onto cxx an alternative make_unique implementation later.
        for ty in &self.types_found {
            let constructor_name = format!("{}_{}", ty, ty);
            if old_name == constructor_name {
                return Ok(());
            }
        }
        s.output = self.convert_return_type(s.output);
        let (new_params, param_details): (Punctuated<_, _>, Vec<_>) = fun
            .sig
            .inputs
            .into_iter()
            .map(|i| self.convert_fn_arg(i))
            .unzip();
        s.inputs = new_params;
        let is_a_method = param_details.iter().any(|b| b.was_self);

        let mut rust_name = old_name.clone();
        if is_a_method {
            // bindgen generates methods with the name:
            // {class}_{method name}
            // It then generates an impl section for the Rust type
            // with the original name, but we currently discard that impl section.
            // We want to feed cxx methods with just the method name, so let's
            // strip off the class name.
            // TODO test with class names containing underscores. It should work.
            for cn in &self.types_found {
                let cn = cn.to_string();
                if old_name.starts_with(&cn) {
                    rust_name = old_name[cn.len() + 1..].to_string();
                    s.ident = Ident::new(&rust_name, s.ident.span());
                    break;
                }
            }
        }

        let unique_ptr_wrapper_needed = param_details.iter().any(|b| b.conversion.work_needed());
        let ret_type_conversion = self.unwrap_return_type(s.output.clone());
        let ret_type_conversion_needed = ret_type_conversion
            .as_ref()
            .map_or(false, |x| x.work_needed());
        let new_item = if unique_ptr_wrapper_needed || ret_type_conversion_needed {
            // First give instructions to generate the additional C++.
            let a = AdditionalNeed::ByValueWrapper(ByValueWrapper {
                id: s.ident.clone(),
                return_conversion: ret_type_conversion.clone(),
                argument_conversion: param_details
                    .iter()
                    .map(|d| d.conversion.clone())
                    .collect(),
                is_a_method,
            });
            self.additional_cpp_needs.push(a);
            // Now generate the additional Rust line required in the cxx::bridge mod.
            let fn_name = make_ident(&format!("{}_up_wrapper", s.ident.to_string()));
            let mut ret_type = s.output.clone();
            if let Some(conversion) = ret_type_conversion {
                let new_ret_type = conversion.unconverted_rust_type();
                ret_type = parse_quote!(
                    -> #new_ret_type
                );
            }
            let arg_list = param_details
                .iter()
                .map(|pd| {
                    let type_name = pd.conversion.converted_rust_type();
                    let arg_name = if pd.was_self {
                        parse_quote!(autocxx_gen_this)
                    } else {
                        pd.name.clone()
                    };
                    parse_quote!(
                        #arg_name: #type_name
                    )
                })
                .collect::<Vec<FnArg>>();
            parse_quote!(
                #[rust_name = #rust_name]
                fn #fn_name ( #(#arg_list),* ) #ret_type;
            )
        } else {
            let attrs = self.strip_attr(fun.attrs, "link_name");
            ForeignItemFn {
                attrs,
                vis: fun.vis,
                sig: s,
                semi_token: fun.semi_token,
            }
        };
        self.extern_c_mod_items.push(ForeignItem::Fn(new_item));
        Ok(())
    }

    fn unwrap_return_type(&self, ret_type: ReturnType) -> Option<ArgumentConversion> {
        match ret_type {
            ReturnType::Type(_, boxed_type) => Some(
                if !self
                    .byvalue_checker
                    .is_pod(&TypeName::from_cxx_type(&*boxed_type))
                {
                    ArgumentConversion::new_to_unique_ptr(*boxed_type)
                } else {
                    ArgumentConversion::new_unconverted(*boxed_type)
                },
            ),
            ReturnType::Default => None,
        }
    }

    fn strip_attr(&self, attrs: Vec<Attribute>, to_strip: &str) -> Vec<Attribute> {
        attrs
            .into_iter()
            .filter(|a| {
                let i = a.path.get_ident();
                !matches!(i, Some(i2) if *i2 == to_strip)
            })
            .collect::<Vec<Attribute>>()
    }

    /// Returns additionally a Boolean indicating whether an argument was
    /// 'this' and another one indicating whether we took a type by value
    /// and that type was non-trivial.
    ///
    /// Regarding autocxx_gen_this, this pertains to what happens if
    /// we come across a *method* which takes or returns a non-POD type
    /// by value (for example a std::string or a struct containing a
    /// std::string). For normal functions, additional_cpp_generator
    /// generates a wrapper method which effectively boxes/unboxes
    /// values from unique_ptr to the desired by-value type.
    ///
    /// For methods, we generate a similar wrapper, but it's not a
    /// member of the original class - it's just a standalone function.
    /// On the C++ side this method is happy to call the original
    /// member function of the class, and all is well. But then we come
    /// back here during the second invocation of bridge_converter,
    /// and discover the new function we generated. We then have to
    /// decide how to teach cxx about that function, and neither
    /// option is satisfactory:
    /// 1) If we rename the first parameter to 'self' then cxx
    ///    will treat it as a method. This is what we want because
    ///    it means we can call it from Rust like this:
    ///      my_object.methodWhichTakesValue(uniquePtrToArg)
    ///    But, in cxx's own generated code, it will insist on calling
    ///      Type::methodWhichTakesValue(...)
    ///    That doesn't work, since our autogenerated
    ///    methodWhichTakesValue (actually called
    ///    methodWhichTakesValue_up_wrapper) is just a function.
    /// 2) Don't give the first parameter a special name. In which case
    ///    we will generate a standalone function on the Rust side.
    fn convert_fn_arg(&self, arg: FnArg) -> (FnArg, ArgumentAnalysis) {
        match arg {
            FnArg::Typed(mut pt) => {
                let mut found_this = false;
                let old_pat = *pt.pat;
                let new_pat = match old_pat {
                    syn::Pat::Ident(mut pp) if pp.ident == "this" =>
                    // TODO - consider also spotting
                    // autocxx_gen_this as per above big comment.
                    {
                        found_this = true;
                        pp.ident = Ident::new("self", pp.ident.span());
                        syn::Pat::Ident(pp)
                    }
                    _ => old_pat,
                };
                let new_ty = self.convert_boxed_type(pt.ty);
                let conversion = self.conversion_required(&new_ty);
                pt.pat = Box::new(new_pat.clone());
                pt.ty = new_ty;
                (
                    FnArg::Typed(pt),
                    ArgumentAnalysis {
                        was_self: found_this,
                        name: new_pat,
                        conversion,
                    },
                )
            }
            _ => panic!("FnArg::Receiver not yet handled"),
        }
    }

    fn conversion_required(&self, ty: &Type) -> ArgumentConversion {
        match ty {
            Type::Path(p) => {
                if self
                    .byvalue_checker
                    .is_pod(&TypeName::from_cxx_type_path(p))
                {
                    ArgumentConversion::new_unconverted(ty.clone())
                } else {
                    ArgumentConversion::new_from_unique_ptr(ty.clone())
                }
            }
            _ => ArgumentConversion::new_unconverted(ty.clone()),
        }
    }

    fn convert_return_type(&self, rt: ReturnType) -> ReturnType {
        match rt {
            ReturnType::Default => ReturnType::Default,
            ReturnType::Type(rarrow, typebox) => {
                ReturnType::Type(rarrow, self.convert_boxed_type(typebox))
            }
        }
    }

    fn convert_boxed_type(&self, ty: Box<Type>) -> Box<Type> {
        Box::new(self.convert_type(*ty))
    }

    fn convert_type(&self, ty: Type) -> Type {
        match ty {
            Type::Path(p) => {
                let newp = self.convert_type_path(p);
                // Special handling because rust_Str (as emitted by bindgen)
                // doesn't simply get renamed to a different type _identifier_.
                // This plain type-by-value (as far as bindgen is concerned)
                // is actually a &str.
                if should_dereference_in_cpp(&newp) {
                    Type::Reference(parse_quote! {
                        &str
                    })
                } else {
                    Type::Path(newp)
                }
            }
            Type::Reference(mut r) => {
                r.elem = self.convert_boxed_type(r.elem);
                Type::Reference(r)
            }
            Type::Ptr(ptr) => Type::Reference(self.convert_ptr_to_reference(ptr)),
            _ => ty,
        }
    }

    fn convert_ptr_to_reference(&self, ptr: TypePtr) -> TypeReference {
        let mutability = ptr.mutability;
        let elem = self.convert_boxed_type(ptr.elem);
        // TODO - in the future, we should check if this is a rust::Str and throw
        // a wobbler if not. rust::Str should only be seen _by value_ in C++
        // headers; it manifests as &str in Rust but on the C++ side it must
        // be a plain value. We should detect and abort.
        parse_quote! {
            & #mutability #elem
        }
    }

    fn convert_type_path(&self, mut typ: TypePath) -> TypePath {
        if typ.path.segments.iter().next().unwrap().ident.to_string() == "root" {
            typ.path.segments = typ
                .path
                .segments
                .into_iter()
                .skip(1) // skip root
                .map(|s| -> PathSegment {
                    let ident = &s.ident;
                    let args = match s.arguments {
                        PathArguments::AngleBracketed(mut ab) => {
                            ab.args = self.convert_punctuated(ab.args);
                            PathArguments::AngleBracketed(ab)
                        }
                        _ => s.arguments,
                    };
                    parse_quote!( #ident #args )
                })
                .collect();
        }
        Self::replace_cpp_with_cxx(typ)
    }

    fn replace_cpp_with_cxx(typ: TypePath) -> TypePath {
        let mut last_seg_args = None;
        let mut seg_iter = typ.path.segments.iter().peekable();
        while let Some(seg) = seg_iter.next() {
            if !seg.arguments.is_empty() {
                if seg_iter.peek().is_some() {
                    panic!("Found a type with path arguments not on the last segment")
                } else {
                    last_seg_args = Some(seg.arguments.clone());
                }
            }
        }
        drop(seg_iter);
        // This line will strip off any path arguments...
        let mut typ = replace_type_path_without_arguments(typ);
        // but then we'll put them back again as necessary.
        if let Some(last_seg_args) = last_seg_args {
            let last_seg = typ.path.segments.last_mut().unwrap();
            last_seg.arguments = last_seg_args;
        }
        typ
    }

    fn convert_punctuated<P>(
        &self,
        pun: Punctuated<GenericArgument, P>,
    ) -> Punctuated<GenericArgument, P>
    where
        P: Default,
    {
        let mut new_pun = Punctuated::new();
        for arg in pun.into_iter() {
            new_pun.push(match arg {
                GenericArgument::Type(t) => GenericArgument::Type(self.convert_type(t)),
                _ => arg,
            });
        }
        new_pun
    }
}

struct ArgumentAnalysis {
    conversion: ArgumentConversion,
    name: Pat,
    was_self: bool,
}
